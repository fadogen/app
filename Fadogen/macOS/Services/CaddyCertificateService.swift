import Foundation
import OSLog
import Security

@Observable
final class CaddyCertificateService {
    var lastInstallStatus: String?

    private let logger = Logger(subsystem: "app.fadogen.Fadogen", category: "caddy-cert")

    private var certificatePath: URL {
        FadogenPaths.caddyDataDirectory
            .appendingPathComponent("pki")
            .appendingPathComponent("authorities")
            .appendingPathComponent("local")
            .appendingPathComponent("root.crt")
    }

    func installCertificateIfNeeded() async {
        do {
            try await installCertificate()
        } catch CaddyCertificateError.certificateNotFound {
            logger.debug("Certificate not yet generated by Caddy, skipping installation")
        } catch {
            logger.error("Failed to install certificate: \(error.localizedDescription)")
        }
    }

    /// Install Caddy certificate to macOS Keychain
    /// This will prompt the user for authorization via GUI
    private func installCertificate() async throws {
        logger.info("Installing Caddy certificate from \(self.certificatePath.path)")

        // Load and parse certificate
        guard let certificate = loadCertificateFromFile() else {
            // Determine specific error for better diagnostics
            if !FileManager.default.fileExists(atPath: certificatePath.path) {
                throw CaddyCertificateError.certificateNotFound
            }
            throw CaddyCertificateError.certificateCreationFailed
        }

        // Get certificate subject for logging
        guard let subjectSummary = SecCertificateCopySubjectSummary(certificate) as String? else {
            throw CaddyCertificateError.subjectReadFailed
        }

        logger.info("Checking certificate: \(subjectSummary)")

        // Check if certificate is already installed with correct trust settings
        if isCertificateAlreadyTrusted(certificate) {
            logger.info("✅ Certificate already installed and trusted, skipping installation")
            lastInstallStatus = "Certificate '\(subjectSummary)' already trusted"
            return
        }

        logger.info("Installing certificate: \(subjectSummary)")

        // Install to macOS Keychain (this will prompt for authorization)
        try await installToMacOSKeychain(certificate: certificate, subjectSummary: subjectSummary)

        lastInstallStatus = "Certificate '\(subjectSummary)' installed successfully"
        logger.info("✅ Certificate installed successfully")
    }

    /// Check if certificate file exists and is already trusted in Keychain
    /// Used for quick checks to avoid unnecessary polling
    func isCertificateAlreadyInstalled() -> Bool {
        guard let certificate = loadCertificateFromFile() else {
            return false
        }
        return isCertificateAlreadyTrusted(certificate)
    }

    /// Load certificate from file and convert to SecCertificate
    private func loadCertificateFromFile() -> SecCertificate? {
        guard FileManager.default.fileExists(atPath: certificatePath.path),
              let pemData = try? Data(contentsOf: certificatePath),
              let pemString = String(data: pemData, encoding: .utf8) else {
            return nil
        }

        // Convert PEM to DER format
        let pemLines = pemString.components(separatedBy: .newlines)
        let base64Cert = pemLines
            .filter { !$0.hasPrefix("-----") && !$0.isEmpty }
            .joined()

        guard let derData = Data(base64Encoded: base64Cert) else {
            return nil
        }

        return SecCertificateCreateWithData(nil, derData as CFData)
    }

    /// Check if certificate is already installed with correct trust settings
    /// Returns true if certificate has kSecTrustSettingsResultTrustRoot set
    private func isCertificateAlreadyTrusted(_ certificate: SecCertificate) -> Bool {
        // Try to get existing trust settings for admin domain
        var trustSettings: CFArray?
        let status = SecTrustSettingsCopyTrustSettings(certificate, .admin, &trustSettings)

        // If no settings exist, certificate is not trusted
        guard status == errSecSuccess, let settings = trustSettings as? [[String: Any]] else {
            return false
        }

        // Check if any trust setting has kSecTrustSettingsResultTrustRoot (value: 1)
        // This indicates the certificate is trusted as a root CA
        for setting in settings {
            if let result = setting[kSecTrustSettingsResult as String] as? Int,
               result == 1 {  // kSecTrustSettingsResultTrustRoot = 1
                return true
            }
        }

        return false
    }

    /// Install certificate to macOS System Keychain with trusted settings
    /// This will automatically show an authorization dialog to the user
    private func installToMacOSKeychain(certificate: SecCertificate, subjectSummary: String) async throws {
        // Add certificate to keychain (without trust settings yet)
        var status = SecCertificateAddToKeychain(certificate, nil)

        // Ignore "duplicate" error - certificate is already in keychain but not trusted
        if status == errSecDuplicateItem {
            logger.debug("Certificate already in keychain, adding trust settings")
            status = errSecSuccess
        }

        guard status == errSecSuccess else {
            throw CaddyCertificateError.keychainAddFailed(status: status)
        }

        // Set trust settings - THIS will prompt for admin password via GUI
        // kSecTrustSettingsResultTrustRoot = 1 (trust as root CA)
        let trustSettings: [String: Any] = [
            kSecTrustSettingsResult as String: 1 as CFNumber
        ]

        status = SecTrustSettingsSetTrustSettings(
            certificate,
            .admin,  // System-wide trust
            trustSettings as CFTypeRef
        )

        guard status == errSecSuccess else {
            throw CaddyCertificateError.trustSettingsFailed(status: status, reason: mapSecurityError(status))
        }

        logger.info("Certificate trusted successfully")
    }

    /// Map OSStatus error codes to human-readable messages
    private func mapSecurityError(_ status: OSStatus) -> String {
        switch status {
        case errSecAuthFailed:
            return "Authorization failed. User cancelled or entered wrong password."
        case errSecUserCanceled:
            return "User cancelled the authorization dialog."
        case errSecNotTrusted:
            return "Authorization required but not possible in current context."
        default:
            return "Failed to set trust settings (OSStatus: \(status))"
        }
    }
}

// MARK: - Errors

enum CaddyCertificateError: LocalizedError {
    case certificateNotFound
    case certificateCreationFailed
    case subjectReadFailed
    case keychainAddFailed(status: OSStatus)
    case trustSettingsFailed(status: OSStatus, reason: String)

    var errorDescription: String? {
        switch self {
        case .certificateNotFound:
            return "Certificate file does not exist"
        case .certificateCreationFailed:
            return "Failed to create certificate object"
        case .subjectReadFailed:
            return "Failed to read certificate subject"
        case .keychainAddFailed(let status):
            return "Failed to add certificate to keychain (OSStatus: \(status))"
        case .trustSettingsFailed(let status, let reason):
            return "Failed to set trust settings (OSStatus: \(status)): \(reason)"
        }
    }
}
