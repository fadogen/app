name: Release

on:
  push:
    tags:
      - 'v*'

permissions:
  contents: write

env:
  APP_NAME: Fadogen
  SCHEME: Fadogen
  PROJECT: Fadogen.xcodeproj

jobs:
  build-and-release:
    runs-on: macos-26

    steps:
      - name: Checkout
        uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: Setup Xcode
        uses: maxim-lobanov/setup-xcode@v1
        with:
          xcode-version: latest-stable

      - name: Install Dependencies
        run: |
          brew install create-dmg
          # Download Sparkle tools for signing
          curl -L -o sparkle.tar.xz https://github.com/sparkle-project/Sparkle/releases/download/2.8.1/Sparkle-2.8.1.tar.xz
          mkdir -p sparkle-tools
          tar -xf sparkle.tar.xz -C sparkle-tools
          chmod +x sparkle-tools/bin/*

      - name: Import Code Signing Certificate and Provisioning Profile
        env:
          BUILD_CERTIFICATE_BASE64: ${{ secrets.BUILD_CERTIFICATE_BASE64 }}
          P12_PASSWORD: ${{ secrets.P12_PASSWORD }}
          KEYCHAIN_PASSWORD: ${{ secrets.KEYCHAIN_PASSWORD }}
          PROVISIONING_PROFILE_BASE64: ${{ secrets.PROVISIONING_PROFILE_BASE64 }}
        run: |
          # Create temporary keychain
          KEYCHAIN_PATH=$RUNNER_TEMP/signing.keychain-db

          # Decode certificate
          echo "$BUILD_CERTIFICATE_BASE64" | base64 --decode > certificate.p12

          # Create and configure keychain
          security create-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security set-keychain-settings -lut 21600 "$KEYCHAIN_PATH"
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"

          # Import certificate
          security import certificate.p12 -k "$KEYCHAIN_PATH" -P "$P12_PASSWORD" -T /usr/bin/codesign -T /usr/bin/security
          security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security list-keychain -d user -s "$KEYCHAIN_PATH"

          # Cleanup certificate
          rm certificate.p12

          # Install provisioning profile
          mkdir -p ~/Library/MobileDevice/Provisioning\ Profiles
          echo "$PROVISIONING_PROFILE_BASE64" | base64 --decode > profile.provisioningprofile

          # Extract UUID from provisioning profile
          PROFILE_UUID=$(/usr/libexec/PlistBuddy -c "Print :UUID" /dev/stdin <<< $(security cms -D -i profile.provisioningprofile))

          # Copy profile with UUID as filename (.provisionprofile for macOS)
          cp profile.provisioningprofile ~/Library/MobileDevice/Provisioning\ Profiles/$PROFILE_UUID.provisionprofile
          rm profile.provisioningprofile

          # Export for later steps
          echo "KEYCHAIN_PATH=$KEYCHAIN_PATH" >> $GITHUB_ENV
          echo "PROFILE_UUID=$PROFILE_UUID" >> $GITHUB_ENV

      - name: Resolve Package Dependencies
        run: |
          xcodebuild -resolvePackageDependencies \
            -project "$PROJECT" \
            -scheme "$SCHEME"

      - name: Set Version from Tag
        run: |
          # Get tag name from ref
          TAG_NAME="${{ github.ref_name }}"
          # Extract version from tag (v1.0.0-alpha.2 -> 1.0.0-alpha.2)
          VERSION="${TAG_NAME#v}"
          echo "VERSION=$VERSION" >> $GITHUB_ENV
          echo "TAG_NAME=$TAG_NAME" >> $GITHUB_ENV

      - name: Build and Archive
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          xcodebuild archive \
            -project "$PROJECT" \
            -scheme "$SCHEME" \
            -configuration Release \
            -destination "generic/platform=macOS" \
            -archivePath "$RUNNER_TEMP/$APP_NAME.xcarchive" \
            ARCHS=arm64 \
            MARKETING_VERSION="${{ env.VERSION }}" \
            CURRENT_PROJECT_VERSION="${{ github.run_number }}" \
            DEVELOPMENT_TEAM="${{ secrets.APPLE_TEAM_ID }}" \
            CODE_SIGN_IDENTITY="Developer ID Application" \
            OTHER_CODE_SIGN_FLAGS="--keychain $KEYCHAIN_PATH"

      - name: Export Archive
        env:
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        run: |
          /usr/libexec/PlistBuddy -c "Clear dict" "$RUNNER_TEMP/ExportOptions.plist"
          /usr/libexec/PlistBuddy -c "Add :method string developer-id" "$RUNNER_TEMP/ExportOptions.plist"
          /usr/libexec/PlistBuddy -c "Add :signingStyle string manual" "$RUNNER_TEMP/ExportOptions.plist"
          /usr/libexec/PlistBuddy -c "Add :teamID string ${APPLE_TEAM_ID}" "$RUNNER_TEMP/ExportOptions.plist"
          /usr/libexec/PlistBuddy -c "Add :signingCertificate string 'Developer ID Application'" "$RUNNER_TEMP/ExportOptions.plist"
          /usr/libexec/PlistBuddy -c "Add :provisioningProfiles dict" "$RUNNER_TEMP/ExportOptions.plist"
          /usr/libexec/PlistBuddy -c "Add :provisioningProfiles:app.fadogen.Fadogen string 'Fadogen Developer ID'" "$RUNNER_TEMP/ExportOptions.plist"

          xcodebuild -exportArchive \
            -archivePath "$RUNNER_TEMP/$APP_NAME.xcarchive" \
            -exportPath "$RUNNER_TEMP/Export" \
            -exportOptionsPlist "$RUNNER_TEMP/ExportOptions.plist"

      - name: Sign Bundled Binaries
        run: |
          cd "$RUNNER_TEMP/Export/$APP_NAME.app/Contents/Resources"

          # Sign all standalone executables with hardened runtime
          for binary in yq mailpit caddy cloudflared; do
            if [ -f "$binary" ]; then
              codesign --force --sign "Developer ID Application" \
                --keychain "$KEYCHAIN_PATH" \
                --options runtime \
                "$binary"
            fi
          done

          # Sign Python binaries
          if [ -d "python/bin" ]; then
            find python/bin -type f -perm +111 | while read binary; do
              codesign --force --sign "Developer ID Application" \
                --keychain "$KEYCHAIN_PATH" \
                --options runtime \
                "$binary"
            done
          fi

          # Sign Ansible binaries if present
          if [ -d "ansible/bin" ]; then
            find ansible/bin -type f -perm +111 | while read binary; do
              codesign --force --sign "Developer ID Application" \
                --keychain "$KEYCHAIN_PATH" \
                --options runtime \
                "$binary"
            done
          fi

          # Re-sign the app to update the seal (preserve entitlements from Xcode export)
          cd "$RUNNER_TEMP/Export"
          codesign --force --sign "Developer ID Application" \
            --keychain "$KEYCHAIN_PATH" \
            --options runtime \
            --preserve-metadata=entitlements \
            "$APP_NAME.app"

      - name: Create and Notarize DMG
        env:
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_APP_PASSWORD: ${{ secrets.APPLE_APP_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        run: |
          cd "$RUNNER_TEMP/Export"

          # Create DMG with create-dmg
          create-dmg \
            --volname "$APP_NAME" \
            --window-pos 200 120 \
            --window-size 600 400 \
            --icon-size 100 \
            --icon "$APP_NAME.app" 150 190 \
            --hide-extension "$APP_NAME.app" \
            --app-drop-link 450 190 \
            "$APP_NAME-$TAG_NAME.dmg" \
            "$APP_NAME.app" || true

          # Verify DMG was created
          if [ ! -f "$APP_NAME-$TAG_NAME.dmg" ]; then
            echo "Error: DMG creation failed"
            exit 1
          fi

          # Sign DMG with Developer ID (required before notarization)
          codesign --sign "Developer ID Application" \
            --keychain "$KEYCHAIN_PATH" \
            "$APP_NAME-$TAG_NAME.dmg"

          # Store notarization credentials
          xcrun notarytool store-credentials "notary-profile" \
            --apple-id "$APPLE_ID" \
            --password "$APPLE_APP_PASSWORD" \
            --team-id "$APPLE_TEAM_ID"

          # Notarize DMG (also validates .app inside)
          xcrun notarytool submit "$APP_NAME-$TAG_NAME.dmg" \
            --keychain-profile "notary-profile" \
            --wait

          xcrun stapler staple "$APP_NAME-$TAG_NAME.dmg"

      - name: Create GitHub Release (Draft)
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          cd "$RUNNER_TEMP/Export"

          # Detect pre-release from tag name (alpha, beta, rc)
          if [[ "$TAG_NAME" =~ (alpha|beta|rc) ]]; then
            PRERELEASE_FLAG="--prerelease"
          else
            PRERELEASE_FLAG=""
          fi

          # Create draft release with DMG and auto-generated notes
          gh release create "$TAG_NAME" \
            "$APP_NAME-$TAG_NAME.dmg" \
            --repo "${{ github.repository }}" \
            --title "$TAG_NAME" \
            --generate-notes \
            --draft \
            $PRERELEASE_FLAG

      - name: Sign with Sparkle EdDSA and Generate Appcast
        env:
          SPARKLE_PRIVATE_KEY: ${{ secrets.SPARKLE_PRIVATE_KEY }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          cd "$RUNNER_TEMP/Export"

          # Fetch HTML release notes from GitHub API
          RAW_NOTES=$(gh api \
            -H "Accept: application/vnd.github.full+json" \
            "/repos/${{ github.repository }}/releases/tags/$TAG_NAME" \
            -q .body_html)

          # Parse: extract only What's Changed list, remove contributor attributions
          RELEASE_BODY=$(echo "$RAW_NOTES" | \
            awk '
              /<h2[^>]*>What.*Changed<\/h2>/ { capture=1; next }
              /<h2[^>]*>/ { capture=0 }
              /<p><strong>Full Changelog/ { capture=0 }
              capture { print }
            ' | \
            sed -E 's/ by <a [^>]*>@[^<]+<\/a> in <a [^>]*>[^<]+<\/a>//g')

          # Sign DMG with Sparkle's EdDSA key (pipe key via stdin with -f -)
          SIGNATURE=$(echo "$SPARKLE_PRIVATE_KEY" | "$GITHUB_WORKSPACE/sparkle-tools/bin/sign_update" -f - "$APP_NAME-$TAG_NAME.dmg")

          # Parse signature and length (both on same line: sparkle:edSignature="..." length="...")
          ED_SIGNATURE=$(echo "$SIGNATURE" | sed -n 's/.*edSignature="\([^"]*\)".*/\1/p')
          LENGTH=$(echo "$SIGNATURE" | sed -n 's/.*length="\([^"]*\)".*/\1/p')

          # Get version and minimum system version from app bundle
          VERSION=$(/usr/libexec/PlistBuddy -c "Print :CFBundleShortVersionString" "$APP_NAME.app/Contents/Info.plist")
          BUILD=$(/usr/libexec/PlistBuddy -c "Print :CFBundleVersion" "$APP_NAME.app/Contents/Info.plist")
          MIN_SYSTEM_VERSION=$(/usr/libexec/PlistBuddy -c "Print :LSMinimumSystemVersion" "$APP_NAME.app/Contents/Info.plist")

          # Get current date in RFC 2822 format
          PUB_DATE=$(date -R)

          # DMG download URL
          DMG_URL="https://github.com/${{ github.repository }}/releases/download/$TAG_NAME/$APP_NAME-$TAG_NAME.dmg"

          # Set channel for pre-releases (alpha, beta, rc)
          if [[ "$TAG_NAME" =~ (alpha|beta|rc) ]]; then
            CHANNEL_TAG="<sparkle:channel>beta</sparkle:channel>"
          else
            CHANNEL_TAG=""
          fi

          # Generate appcast.xml
          cat > appcast.xml << EOF
          <?xml version="1.0" encoding="utf-8"?>
          <rss version="2.0" xmlns:sparkle="http://www.andymatuschak.org/xml-namespaces/sparkle" xmlns:dc="http://purl.org/dc/elements/1.1/">
            <channel>
              <title>$APP_NAME Updates</title>
              <link>https://fouteox.github.io/fadogen-app/appcast.xml</link>
              <description>Most recent changes with links to updates.</description>
              <language>en</language>
              <item>
                <title>Version $VERSION</title>
                $CHANNEL_TAG
                <description><![CDATA[$RELEASE_BODY]]></description>
                <pubDate>$PUB_DATE</pubDate>
                <sparkle:version>$BUILD</sparkle:version>
                <sparkle:shortVersionString>$VERSION</sparkle:shortVersionString>
                <sparkle:minimumSystemVersion>$MIN_SYSTEM_VERSION</sparkle:minimumSystemVersion>
                <enclosure url="$DMG_URL"
                           sparkle:edSignature="$ED_SIGNATURE"
                           length="$LENGTH"
                           type="application/octet-stream"/>
              </item>
            </channel>
          </rss>
          EOF

      - name: Deploy Appcast to GitHub Pages
        uses: peaceiris/actions-gh-pages@v4
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: ${{ runner.temp }}/Export
          keep_files: true
          exclude_assets: "*.app,*.zip,*.dmg"

      - name: Publish Release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh release edit "$TAG_NAME" --repo "${{ github.repository }}" --draft=false

      - name: Cleanup
        if: always()
        run: |
          security delete-keychain "$RUNNER_TEMP/signing.keychain-db" || true
          rm -rf ~/Library/MobileDevice/Provisioning\ Profiles || true
